<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manual Operasional Sistem Raspberry Pi | 22 Modul Terstruktur</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --bg-color: #1a1b26;
            --card-color: #24283b;
            --text-color: #c0caf5;
            --header-color: #ffffff;
            --accent-color-1: #bb9af7; /* Purple */
            --accent-color-2: #7aa2f7; /* Blue */
            --accent-color-green: #9ece6a;
            --accent-color-yellow: #e0af68;
            --accent-color-red: #f7768e;
            --border-color: #414868;
            --code-bg-color: #1e202e;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html { scroll-behavior: smooth; }

        body {
            background-color: var(--bg-color);
            background-image: radial-gradient(circle at 50% 0%, rgba(122, 162, 247, 0.1), transparent 40%);
            color: var(--text-color);
            font-family: 'Poppins', sans-serif;
            line-height: 1.8;
            padding: 2rem 1rem;
        }

        .container { max-width: 900px; margin: 0 auto; }

        header { text-align: center; margin-bottom: 3rem; }
        header h1 {
            font-family: 'Roboto Mono', monospace;
            color: var(--header-color);
            font-size: clamp(2rem, 5vw, 2.8rem);
            margin-bottom: 0.5rem;
            text-shadow: 0 0 8px rgba(122, 162, 247, 0.5);
            letter-spacing: -1px;
        }
        header p { color: var(--accent-color-1); font-size: 1.1rem; max-width: 600px; margin: 0 auto; }
        
        .progress-container {
            width: 100%;
            background-color: var(--card-color);
            border-radius: 25px;
            margin-top: 2rem;
            border: 1px solid var(--border-color);
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .progress-bar {
            width: 0%;
            height: 25px;
            background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2));
            border-radius: 25px;
            text-align: center;
            line-height: 25px;
            color: #1a1b26;
            font-weight: bold;
            transition: width 0.8s cubic-bezier(0.25, 1, 0.5, 1);
            font-family: 'Roboto Mono', monospace;
            text-shadow: 0 0 2px rgba(255,255,255,0.3);
        }
        
        .intro-text {
            text-align: center;
            margin-bottom: 2rem;
            color: var(--text-color);
            font-style: italic;
        }

        .module-card {
            background-color: var(--card-color);
            border-radius: 12px;
            margin-bottom: 1.25rem;
            border: 1px solid var(--border-color);
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        .module-card:hover { transform: translateY(-3px); box-shadow: 0 8px 25px rgba(0,0,0,0.2); }
        .module-card.completed { border-left: 5px solid var(--accent-color-green); }

        .module-header {
            padding: 1.25rem 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 1rem;
            background-color: rgba(0,0,0,0.1);
        }
        .module-header:hover { background-color: rgba(187, 154, 247, 0.1); }

        .module-number {
            font-family: 'Roboto Mono', monospace;
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent-color-1);
            min-width: 30px;
            text-align: right;
        }
        .module-icon { font-size: 1.5rem; color: var(--accent-color-2); width: 30px; text-align: center; transition: transform 0.3s ease; }
        .module-title { flex-grow: 1; font-size: 1.15rem; font-weight: 600; color: var(--header-color); }
        .tag { padding: 0.2rem 0.6rem; border-radius: 15px; font-size: 0.8rem; font-weight: bold; color: #1a1b26; flex-shrink: 0; }
        .tag-dasar { background-color: var(--accent-color-green); }
        .tag-menengah { background-color: var(--accent-color-yellow); }
        .tag-lanjutan { background-color: var(--accent-color-red); }

        .complete-btn {
            background: none; border: 2px solid var(--border-color); color: var(--border-color);
            width: 32px; height: 32px; border-radius: 50%; cursor: pointer;
            transition: all 0.3s ease; font-size: 1.1rem; flex-shrink: 0;
            display: grid; place-items: center;
        }
        .complete-btn:hover { border-color: var(--accent-color-green); color: var(--accent-color-green); transform: scale(1.1); }
        .completed .complete-btn { background-color: var(--accent-color-green); border-color: var(--accent-color-green); color: var(--card-color); font-weight: bold; }

        .module-body {
            max-height: 0; overflow: hidden;
            transition: max-height 0.6s cubic-bezier(0.4, 0, 0.2, 1), padding 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 0 1.5rem;
        }
        .module-body-content { padding: 1.5rem; border-top: 1px solid var(--border-color); }
        /* BUG FIX: Increased max-height to a very large value to prevent content clipping on mobile */
        .module-card.active .module-body { max-height: 5000px; }
        .module-card.active .module-icon { transform: rotate(90deg); }

        .module-body h5 {
            color: var(--accent-color-1); font-size: 1rem; margin-top: 2rem; margin-bottom: 1rem;
            font-family: 'Roboto Mono', monospace; border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem; display: flex; align-items: center; gap: 0.75rem;
        }
        .module-body h5:first-child { margin-top: 0; }
        .module-body h5 i { color: var(--accent-color-2); font-size: 0.9rem; }

        .module-body p, .module-body ol { margin-bottom: 1.5rem; }
        .module-body p { padding-left: 0.5rem; border-left: 2px solid var(--accent-color-2); }
        
        .module-body ol { list-style: none; counter-reset: step-counter; padding-left: 1rem; }
        .module-body ol li {
            counter-increment: step-counter; position: relative;
            padding-left: 2.8rem; margin-bottom: 1.25rem;
        }
        .module-body ol li::before {
            content: counter(step-counter); font-family: 'Roboto Mono', monospace; font-weight: bold;
            position: absolute; left: 0; top: -2px; width: 2rem; height: 2rem;
            background-color: var(--accent-color-2); color: var(--card-color);
            border-radius: 50%; text-align: center; line-height: 2rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        code {
            background-color: var(--code-bg-color); color: var(--accent-color-yellow);
            padding: 0.2em 0.4em; margin: 0 0.2em; border-radius: 4px;
            font-family: 'Roboto Mono', monospace; font-size: 0.9em;
        }

        .ref-links ul { list-style: none; padding-left: 0; }
        .ref-links li { margin-bottom: 0.5rem; }
        .ref-links a {
            color: var(--accent-color-2); text-decoration: none;
            display: inline-flex; align-items: center; gap: 0.5rem;
            transition: all 0.2s ease;
        }
        .ref-links a:hover { color: var(--accent-color-1); text-decoration: underline; padding-left: 5px; }

        .closing-statement {
            text-align: center; margin-top: 3rem; padding: 2.5rem;
            background-color: var(--card-color); border: 1px solid var(--border-color);
            border-radius: 12px;
        }
        .closing-statement h3 { color: var(--accent-color-green); margin-bottom: 1rem; font-size: 1.5rem; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Raspberry Pi Operations Manual</h1>
            <p>22 Modul Pembelajaran Terstruktur untuk Satu Semester</p>
            <div class="progress-container">
                <div class="progress-bar" id="progressBar">0% Selesai</div>
            </div>
        </header>

        <p class="intro-text">Eksekusi setiap modul secara berurutan untuk pembentukan kapabilitas sistem yang optimal.</p>

        <div class="accordion-container">
            <!-- Modul 1 -->
            <div class="module-card" data-module-id="1">
                <div class="module-header">
                    <div class="module-number">01</div><div class="module-icon"><i class="fa-solid fa-power-off"></i></div><div class="module-title">Inisialisasi Sistem Primer</div><div class="tag tag-dasar">Dasar</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                    <div class="module-body-content">
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Mengubah unit Raspberry Pi dari kondisi non-aktif menjadi sistem operasional penuh dengan OS yang terinstal, terkonfigurasi, dan siap untuk interaksi lebih lanjut.</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI</h5>
                        <ol>
                            <li>Akuisisi perangkat lunak resmi <code>Raspberry Pi Imager</code>. Alat ini berfungsi untuk menulis file Sistem Operasi ke kartu MicroSD dengan aman dan benar.</li>
                            <li>Eksekusi Imager. Lakukan seleksi model Raspberry Pi dan Sistem Operasi (rekomendasi: "Raspberry Pi OS" untuk kompatibilitas maksimal).</li>
                            <li>Akses menu pra-konfigurasi (ikon gerigi). Definisikan parameter krusial: <code>hostname</code> (nama unik perangkat di jaringan), aktivasi SSH (untuk akses jarak jauh), kredensial pengguna (<code>username</code>/<code>password</code>), dan detail konektivitas WiFi. Langkah ini mengautomasi konfigurasi awal.</li>
                            <li>Tentukan kartu MicroSD sebagai media target. Inisiasi proses penulisan (<code>write</code>). Perhatian: semua data sebelumnya pada kartu akan dihapus secara permanen.</li>
                            <li>Pasca-penulisan, pasang kartu MicroSD ke Raspberry Pi. Sambungkan periferal (monitor, keyboard, mouse) dan terakhir, sambungkan catu daya untuk memulai urutan boot.</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>Sistem berhasil melakukan boot hingga menampilkan antarmuka desktop grafis. Koneksi ke jaringan WiFi yang ditentukan terjadi secara otomatis tanpa intervensi manual. Tidak ada permintaan konfigurasi tambahan yang muncul.</p>
                        <h5><i class="fa-solid fa-book"></i>ASET & REFERENSI</h5>
                        <div class="ref-links">
                            <ul>
                                <li><a href="https://www.raspberrypi.com/software/" target="_blank" rel="noopener noreferrer"><i class="fa-solid fa-download"></i> Unduh Raspberry Pi Imager</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Modul 2 -->
            <div class="module-card" data-module-id="2">
                <div class="module-header">
                    <div class="module-number">02</div><div class="module-icon"><i class="fa-solid fa-terminal"></i></div><div class="module-title">Dasar Antarmuka Baris Perintah (CLI)</div><div class="tag tag-dasar">Dasar</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                    <div class="module-body-content">
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Menguasai eksekusi perintah fundamental di terminal untuk interaksi non-grafis yang presisi dan efisien dengan sistem operasi Linux.</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI</h5>
                        <ol>
                            <li>Buka aplikasi <code>Terminal</code> dari taskbar. Ini adalah gerbang Anda untuk berkomunikasi langsung dengan sistem.</li>
                            <li>Gunakan <code>pwd</code> (Print Working Directory): Perintah ini untuk menanyakan, "Di folder mana saya berada sekarang?"</li>
                            <li>Gunakan <code>ls -la</code>: Perintah ini untuk meminta daftar rinci semua file dan folder di lokasi saat ini, termasuk file tersembunyi dan hak aksesnya.</li>
                            <li>Buat direktori baru dengan <code>mkdir nama_folder_baru</code>. Ini adalah perintah untuk membuat folder.</li>
                            <li>Pindah ke direktori tersebut dengan <code>cd nama_folder_baru</code>. Ini adalah perintah untuk 'masuk' ke dalam folder.</li>
                            <li>Gunakan <code>nano nama_file.txt</code>. <code>nano</code> adalah editor teks sederhana berbasis terminal untuk membuat atau mengubah file. Simpan dan keluar dengan mengikuti instruksi di bagian bawah layar (<code>Ctrl+X</code>, lalu <code>Y</code>, lalu <code>Enter</code>).</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>Struktur direktori dan file berhasil dibuat melalui terminal. Keberadaan dan isinya dapat diverifikasi menggunakan perintah <code>ls</code> dan <code>cat nama_file.txt</code>, serta terlihat di aplikasi File Manager grafis.</p>
                    </div>
                </div>
            </div>
            <!-- Modul 3 -->
            <div class="module-card" data-module-id="3">
                <div class="module-header">
                    <div class="module-number">03</div><div class="module-icon"><i class="fa-solid fa-user-shield"></i></div><div class="module-title">Manajemen File & Hak Akses</div><div class="tag tag-dasar">Dasar</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                     <div class="module-body-content">
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Memahami perbedaan kritis antara pengguna biasa dan superuser (<code>root</code>). Mengelola hak akses file untuk menjaga integritas dan keamanan sistem.</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI</h5>
                        <ol>
                            <li>Lakukan percobaan terlarang: coba buat file di dalam direktori sistem yang dilindungi, misalnya <code>/etc</code>. Sistem operasi akan menolak perintah ini untuk melindungi file konfigurasinya.</li>
                            <li>Gunakan eskalasi hak akses. Ulangi perintah yang sama, namun awali dengan <code>sudo</code> (Super User Do). Sistem akan meminta kata sandi Anda dan, jika benar, akan mengeksekusi perintah dengan hak akses tertinggi. Ini seperti "meminjam" kekuatan administrator sementara.</li>
                            <li>Inspeksi hak akses dengan <code>ls -l</code>. Perhatikan kolom pertama yang berisi notasi seperti <code>-rwxr--r--</code>. Ini mendefinisikan siapa yang boleh membaca (<code>r</code>), menulis/mengubah (<code>w</code>), dan mengeksekusi (<code>x</code>) file tersebut.</li>
                            <li>Ubah hak akses menggunakan <code>chmod</code> (Change Mode). Perintah ini memungkinkan Anda menambah atau mengurangi izin untuk pemilik file, grup, atau pengguna lain.</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>Menerima pesan galat "Permission Denied" saat mencoba operasi terlarang. Berhasil mengeksekusi perintah yang sama dengan <code>sudo</code>. Berhasil mengubah hak akses file dan memverifikasi perubahannya melalui <code>ls -l</code>.</p>
                    </div>
                </div>
            </div>
            <!-- Modul 4 -->
            <div class="module-card" data-module-id="4">
                <div class="module-header">
                    <div class="module-number">04</div><div class="module-icon"><i class="fa-solid fa-wifi"></i></div><div class="module-title">Konfigurasi Jaringan Statis</div><div class="tag tag-dasar">Dasar</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                     <div class="module-body-content">
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Mengganti alamat IP dinamis (yang bisa berubah setiap kali terhubung) dengan alamat IP statis (tetap dan tidak berubah). Ini krusial untuk perangkat server atau IoT agar selalu dapat ditemukan di alamat yang sama.</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI</h5>
                        <ol>
                            <li>Jalankan utilitas konfigurasi <code>sudo raspi-config</code>. Ini adalah alat bantu berbasis teks yang menyederhanakan banyak pengaturan sistem.</li>
                            <li>Navigasi ke menu "System Options" > "Hostname" untuk mengubah nama perangkat Anda di jaringan menjadi sesuatu yang unik dan deskriptif.</li>
                            <li>Untuk IP Statis, edit file konfigurasi jaringan di <code>/etc/dhcpcd.conf</code> menggunakan <code>sudo nano</code>.</li>
                            <li>Tambahkan blok konfigurasi di akhir file untuk antarmuka jaringan yang digunakan (misal: <code>interface wlan0</code> untuk WiFi), lalu tentukan alamat <code>static ip_address</code> yang diinginkan, serta alamat <code>static routers</code> (biasanya alamat IP router Anda).</li>
                            <li>Simpan file dan restart Raspberry Pi (<code>sudo reboot</code>) agar perubahan jaringan yang fundamental ini dapat diterapkan.</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>Setelah reboot, perintah <code>hostname -I</code> akan menampilkan alamat IP statis yang baru Anda atur. Perangkat dapat di-ping dari komputer lain di jaringan yang sama menggunakan alamat IP statis tersebut, mengonfirmasi konektivitas yang stabil.</p>
                    </div>
                </div>
            </div>
            <!-- Modul 5 -->
            <div class="module-card" data-module-id="5">
                <div class="module-header">
                    <div class="module-number">05</div><div class="module-icon"><i class="fa-solid fa-display"></i></div><div class="module-title">Akses Jarak Jauh (SSH & VNC)</div><div class="tag tag-menengah">Menengah</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                     <div class="module-body-content">
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Mengaktifkan protokol akses jarak jauh untuk memungkinkan operasi tanpa monitor, keyboard, dan mouse (dikenal sebagai operasi "headless"). Ini memungkinkan Anda mengontrol Raspberry Pi dari komputer lain.</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI</h5>
                        <ol>
                            <li>Jalankan kembali utilitas <code>sudo raspi-config</code>.</li>
                            <li>Navigasi ke menu "Interface Options".</li>
                            <li>Aktifkan (Enable) layanan <strong>SSH</strong>. Ini membuka port untuk koneksi terminal (baris perintah) yang aman dan terenkripsi.</li>
                            <li>Aktifkan (Enable) layanan <strong>VNC Server</strong>. Ini mengaktifkan server yang akan menyiarkan tampilan desktop grafis Raspberry Pi melalui jaringan.</li>
                            <li>Dari komputer lain di jaringan yang sama, gunakan klien SSH (seperti Terminal di macOS/Linux atau PuTTY di Windows) untuk terhubung ke alamat IP Raspberry Pi.</li>
                            <li>Unduh dan gunakan <code>RealVNC Viewer</code> di komputer lain untuk terhubung ke alamat IP yang sama dan mendapatkan akses desktop grafis penuh.</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>Berhasil login dan mengeksekusi perintah di terminal Raspberry Pi melalui koneksi SSH. Berhasil melihat dan mengontrol seluruh antarmuka desktop Raspberry Pi dari komputer lain melalui VNC Viewer.</p>
                    </div>
                </div>
            </div>
            <!-- Modul 6 -->
            <div class="module-card" data-module-id="6">
                <div class="module-header">
                    <div class="module-number">06</div><div class="module-icon"><i class="fa-solid fa-file-export"></i></div><div class="module-title">Transfer File via WinSCP (Windows)</div><div class="tag tag-menengah">Menengah</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                     <div class="module-body-content">
                        <h5><i class="fa-solid fa-satellite-dish"></i>PRASYARAT</h5>
                        <p>Modul 05 (Akses Jarak Jauh) harus telah diselesaikan. Layanan SSH harus aktif di Raspberry Pi dan alamat IP-nya diketahui.</p>
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Membangun kanal transfer file yang aman dan intuitif antara komputer Windows dan Raspberry Pi menggunakan antarmuka grafis WinSCP, yang berjalan di atas protokol SSH.</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI</h5>
                        <ol>
                            <li>Di komputer Windows, unduh dan instal aplikasi <code>WinSCP</code>. Ini adalah klien grafis untuk protokol transfer file aman.</li>
                            <li>Jalankan WinSCP. Anda akan disambut oleh jendela "Login".</li>
                            <li>Pilih "File protocol" menjadi <code>SCP</code> (Secure Copy Protocol), yang merupakan pilihan standar untuk transfer file melalui SSH.</li>
                            <li>Masukkan alamat IP Raspberry Pi di kolom "Host name", diikuti dengan nama pengguna dan kata sandi yang telah Anda atur.</li>
                            <li>Klik "Login". Pada koneksi pertama, sebuah peringatan keamanan kunci host akan muncul. Ini normal. Klik "Yes" untuk menyimpan dan mempercayai kunci dari Raspberry Pi Anda.</li>
                            <li>Antarmuka dua panel akan muncul. Panel kiri merepresentasikan sistem file komputer Windows Anda, sedangkan panel kanan merepresentasikan sistem file Raspberry Pi.</li>
                            <li>Untuk mentransfer file, cukup seret (drag and drop) item dari satu panel ke panel lainnya. Operasi ini dapat dilakukan untuk unggah (kiri ke kanan) maupun unduh (kanan ke kiri).</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>File yang diseret dari panel komputer muncul di direktori tujuan pada panel Raspberry Pi (dan sebaliknya). File tersebut dapat diakses dan dibuka di perangkat tujuan, mengonfirmasi transfer data yang berhasil dan tanpa korupsi.</p>
                        <h5><i class="fa-solid fa-book"></i>ASET & REFERENSI</h5>
                        <div class="ref-links">
                            <ul>
                                <li><a href="https://winscp.net/eng/download.php" target="_blank" rel="noopener noreferrer"><i class="fa-solid fa-download"></i> Unduh WinSCP</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Modul 7 -->
            <div class="module-card" data-module-id="7">
                <div class="module-header">
                    <div class="module-number">07</div><div class="module-icon"><i class="fa-brands fa-python"></i></div><div class="module-title">Fundamental Pemrograman Python</div><div class="tag tag-dasar">Dasar</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                    <div class="module-body-content">
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Menguasai konstruksi pemrograman dasar menggunakan bahasa Python, yang merupakan fondasi untuk memberikan instruksi, mengontrol logika, dan berinteraksi dengan komponen elektronik.</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI</h5>
                        <ol>
                            <li>Buka <code>Thonny IDE</code> dari menu "Programming". Thonny adalah lingkungan pengembangan yang ramah pemula yang sudah terinstal di Raspberry Pi OS.</li>
                            <li>Praktikkan Variabel: Buat "wadah" untuk menyimpan data seperti angka, teks, atau daftar (list).</li>
                            <li>Gunakan fungsi <code>print()</code> untuk menampilkan isi dari variabel ke konsol. Ini adalah cara dasar untuk melihat hasil dari program Anda.</li>
                            <li>Tulis struktur Kondisional (<code>if-elif-else</code>). Ini adalah cara program membuat keputusan berdasarkan kondisi tertentu (misal: "jika suhu di atas 30, nyalakan kipas").</li>
                            <li>Implementasikan Perulangan (<code>for</code> dan <code>while</code>). Ini adalah cara untuk mengotomatisasi tugas yang berulang tanpa harus menulis kode yang sama berulang kali.</li>
                            <li>Simpan file dengan ekstensi <code>.py</code> dan jalankan menggunakan tombol "Run" hijau di Thonny.</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>Skrip Python berjalan tanpa menampilkan pesan galat sintaks. Output yang muncul di panel "Shell" Thonny sesuai dengan logika yang telah diprogramkan.</p>
                        <h5><i class="fa-solid fa-book"></i>ASET & REFERENSI</h5>
                        <div class="ref-links">
                            <ul>
                                <li><a href="https://docs.python.org/3/tutorial/index.html" target="_blank" rel="noopener noreferrer"><i class="fa-solid fa-book-open"></i> Tutorial Resmi Python 3</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Modul 8 -->
            <div class="module-card" data-module-id="8">
                <div class="module-header">
                    <div class="module-number">08</div><div class="module-icon"><i class="fa-solid fa-lightbulb"></i></div><div class="module-title">Kontrol Output GPIO (LED Blink)</div><div class="tag tag-menengah">Menengah</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                    <div class="module-body-content">
                        <h5><i class="fa-solid fa-satellite-dish"></i>PRASYARAT</h5>
                        <p>Pemahaman dasar Python (Modul 07) diperlukan.</p>
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Memberikan perintah dari skrip Python untuk mengontrol komponen elektronik eksternal melalui pin General Purpose Input/Output (GPIO), menghasilkan efek fisik yang terlihat.</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI</h5>
                        <ol>
                            <li><b>PROSEDUR KESELAMATAN:</b> Matikan dan cabut catu daya Raspberry Pi sebelum menyambungkan atau melepaskan komponen apa pun dari pin GPIO untuk menghindari kerusakan.</li>
                            <li>Rangkai sirkuit LED: Hubungkan pin GPIO (misal, GPIO17) ke resistor (misal, 330 Ohm) untuk membatasi arus. Hubungkan ujung lain resistor ke kaki panjang LED (anoda). Hubungkan kaki pendek LED (katoda) ke pin Ground (GND).</li>
                            <li>Nyalakan kembali Raspberry Pi dan buka Thonny IDE.</li>
                            <li>Dalam skrip Python, gunakan pustaka <code>gpiozero</code>. Pustaka ini menyederhanakan interaksi dengan pin GPIO. Impor kelas yang relevan, seperti <code>LED</code>.</li>
                            <li>Buat sebuah "objek" dalam kode untuk merepresentasikan LED fisik, dengan memberitahu program nomor pin GPIO mana yang terhubung dengannya.</li>
                            <li>Buat perulangan tak terbatas (<code>while True</code>) yang secara berurutan memanggil metode <code>.on()</code> untuk menyalakan LED, memberi jeda, memanggil metode <code>.off()</code> untuk mematikan LED, dan memberi jeda lagi.</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>LED fisik pada breadboard berkedip secara teratur sesuai dengan interval jeda yang diprogramkan, menunjukkan kontrol output digital yang berhasil.</p>
                        <h5><i class="fa-solid fa-book"></i>ASET & REFERENSI</h5>
                        <div class="ref-links">
                            <ul>
                                <li><a href="https://gpiozero.readthedocs.io/" target="_blank" rel="noopener noreferrer"><i class="fa-solid fa-book-open"></i> Dokumentasi GPIO Zero</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Modul 9 -->
            <div class="module-card" data-module-id="9">
                <div class="module-header">
                    <div class="module-number">09</div><div class="module-icon"><i class="fa-solid fa-ruler-combined"></i></div><div class="module-title">Interfacing Sensor (Digital & Analog)</div><div class="tag tag-menengah">Menengah</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                    <div class="module-body-content">
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Membaca data dari dunia nyata menggunakan sensor, baik yang memberikan sinyal digital (on/off, atau data terstruktur) maupun analog (nilai kontinu seperti suhu).</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI</h5>
                        <ol>
                            <li><b>Sensor Digital (HC-SR04 Ultrasonik):</b> Hubungkan pin VCC ke 5V, GND ke GND, Trig dan Echo ke dua pin GPIO yang berbeda. Gunakan kelas <code>DistanceSensor</code> dari pustaka <code>gpiozero</code> yang menangani logika pengiriman dan penerimaan pulsa suara untuk Anda.</li>
                            <li><b>Sensor Analog (LM35 Suhu):</b> Raspberry Pi tidak memiliki pin input analog. Oleh karena itu, diperlukan komponen perantara bernama ADC (Analog-to-Digital Converter), seperti MCP3008.</li>
                            <li>Hubungkan ADC ke Raspberry Pi menggunakan koneksi SPI (pin khusus untuk komunikasi data berkecepatan tinggi). Lalu hubungkan output dari sensor LM35 ke salah satu channel input ADC.</li>
                            <li>Aktifkan antarmuka SPI melalui <code>sudo raspi-config</code>.</li>
                            <li>Gunakan kelas <code>MCP3008</code> dari pustaka <code>gpiozero</code> untuk membaca nilai mentah dari ADC, lalu konversikan nilai tersebut menjadi tegangan dan suhu menggunakan rumus dari datasheet sensor.</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>Program berhasil mencetak nilai jarak dalam sentimeter dan suhu dalam derajat Celsius. Nilai-nilai ini berubah secara logis ketika sebuah objek didekatkan/dijauhkan dari sensor ultrasonik, atau ketika sensor suhu disentuh.</p>
                    </div>
                </div>
            </div>
            <!-- Modul 10 -->
            <div class="module-card" data-module-id="10">
                <div class="module-header">
                    <div class="module-number">10</div><div class="module-icon"><i class="fa-solid fa-align-left"></i></div><div class="module-title">Visualisasi Data Terminal</div><div class="tag tag-dasar">Dasar</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                    <div class="module-body-content">
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Menampilkan data sensor yang dibaca secara terus-menerus di terminal dengan format yang jelas dan mudah dibaca untuk keperluan pemantauan dan debugging.</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI</h5>
                        <ol>
                            <li>Buat skrip Python yang berisi perulangan tak terbatas (<code>while True</code>).</li>
                            <li>Di dalam perulangan, panggil metode atau fungsi yang membaca nilai dari sensor Anda (misal, <code>sensor.distance</code>).</li>
                            <li>Gunakan fungsi <code>print()</code> dengan f-string. F-string adalah cara modern dan mudah untuk menyisipkan variabel ke dalam teks, misalnya: <code>print(f"Jarak: {jarak:.2f} cm")</code>. Bagian <code>:.2f</code> memformat angka menjadi dua desimal.</li>
                            <li>Gunakan fungsi <code>time.sleep()</code> di akhir setiap iterasi perulangan. Ini memberikan jeda (misal, 1 detik) agar terminal tidak dibanjiri data terlalu cepat dan CPU tidak bekerja 100% terus-menerus.</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>Terminal menampilkan baris data baru secara teratur sesuai interval <code>sleep</code>. Data yang ditampilkan merespons perubahan kondisi sensor secara real-time.</p>
                    </div>
                </div>
            </div>
            <!-- Modul 11 -->
            <div class="module-card" data-module-id="11">
                <div class="module-header">
                    <div class="module-number">11</div><div class="module-icon"><i class="fa-solid fa-diagram-project"></i></div><div class="module-title">Protokol Komunikasi Serial</div><div class="tag tag-lanjutan">Lanjutan</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                    <div class="module-body-content">
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Memahami dan mengaktifkan protokol komunikasi perangkat keras I2C dan UART. Ini adalah "bahasa" yang digunakan Raspberry Pi untuk berbicara dengan berbagai modul canggih dan mikrokontroler lain seperti Arduino.</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI</h5>
                        <ol>
                            <li>Jalankan <code>sudo raspi-config</code> dan navigasi ke "Interface Options".</li>
                            <li>Pilih "I2C" dan aktifkan. I2C adalah bus komunikasi dua kabel yang memungkinkan banyak perangkat terhubung secara bersamaan, masing-masing dengan alamat unik.</li>
                            <li>Pilih "Serial Port". Jawab "No" untuk login shell, dan "Yes" untuk mengaktifkan hardware serial port (UART). UART adalah protokol komunikasi titik-ke-titik.</li>
                            <li>Keluar dari <code>raspi-config</code> dan reboot jika diminta.</li>
                            <li>Instal perkakas bantu dengan <code>sudo apt install i2c-tools</code>.</li>
                            <li>Untuk verifikasi I2C, hubungkan perangkat I2C dan jalankan perintah <code>i2cdetect -y 1</code>. Perintah ini akan memindai bus I2C dan melaporkan alamat perangkat yang terdeteksi.</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>Perintah <code>i2cdetect</code> berhasil menampilkan sebuah tabel dan menunjukkan alamat heksadesimal dari perangkat I2C yang terhubung (misal, <code>40</code> atau <code>77</code>). Ini mengonfirmasi bahwa bus I2C aktif dan perangkat terhubung dengan benar.</p>
                    </div>
                </div>
            </div>
            <!-- Modul 12 -->
            <div class="module-card" data-module-id="12">
                <div class="module-header">
                    <div class="module-number">12</div><div class="module-icon"><i class="fa-solid fa-sun"></i></div><div class="module-title">Implementasi Sensor I2C</div><div class="tag tag-lanjutan">Lanjutan</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                     <div class="module-body-content">
                        <h5><i class="fa-solid fa-satellite-dish"></i>PRASYARAT</h5>
                        <p>Modul 11 (Protokol Komunikasi Serial) harus diselesaikan.</p>
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Membaca data secara spesifik dari sensor yang menggunakan protokol komunikasi I2C. Ini adalah metode yang efisien karena hanya memerlukan dua pin GPIO (SDA dan SCL) terlepas dari jumlah perangkat I2C yang terhubung.</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI</h5>
                        <ol>
                            <li>Matikan Raspberry Pi. Hubungkan pin SDA sensor ke GPIO2, SCL ke GPIO3, VCC ke 3.3V, dan GND ke Ground.</li>
                            <li>Nyalakan Raspberry Pi dan verifikasi koneksi dengan <code>i2cdetect -y 1</code> untuk melihat alamat sensor.</li>
                            <li>Instal pustaka Python yang diperlukan. Seringkali, produsen sensor (seperti Adafruit) menyediakan pustaka khusus yang sangat memudahkan interaksi.</li>
                            <li>Dalam skrip Python, impor pustaka tersebut dan inisialisasi objek sensor. Pustaka akan menangani semua komunikasi I2C tingkat rendah di belakang layar.</li>
                            <li>Panggil metode dari objek sensor untuk membaca data, misalnya <code>sensor.temperature</code> atau <code>sensor.pressure</code>.</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>Skrip berhasil mencetak nilai sensor yang akurat (misalnya, suhu, kelembaban, tekanan) dan nilai tersebut berubah secara responsif terhadap perubahan kondisi lingkungan.</p>
                    </div>
                </div>
            </div>
            <!-- Modul 13 (REVISED FOR BLYNK) -->
            <div class="module-card" data-module-id="13">
                <div class="module-header">
                    <div class="module-number">13</div><div class="module-icon"><i class="fa-solid fa-mobile-screen-button"></i></div><div class="module-title">Integrasi Platform IoT (Blynk)</div><div class="tag tag-menengah">Menengah</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                    <div class="module-body-content">
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Mengirim data dari sensor yang terhubung ke Raspberry Pi ke sebuah dasbor interaktif di perangkat seluler menggunakan platform Blynk, sehingga data dapat dipantau secara real-time dari mana saja.</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI</h5>
                        <ol>
                            <li>Instal aplikasi <strong>Blynk IoT</strong> di perangkat seluler Anda (Android/iOS) dan buat akun.</li>
                            <li>Di dalam aplikasi, buat "Template" baru, lalu buat "Device" dari template tersebut. Proses ini akan menghasilkan sebuah <strong>Auth Token</strong> yang unik. Token ini adalah kunci rahasia yang menghubungkan perangkat keras Anda dengan proyek di aplikasi.</li>
                            <li>Di dalam template, konfigurasikan "Datastreams". Pilih "Virtual Pin" (misal, V1) sebagai kanal untuk data Anda (misal, suhu).</li>
                            <li>Desain dasbor di aplikasi seluler dengan menambahkan "Widget" (seperti Gauge atau Labeled Value) dan hubungkan widget tersebut ke Virtual Pin (V1) yang telah Anda buat.</li>
                            <li>Di Raspberry Pi, instal pustaka Python resmi untuk Blynk menggunakan <code>pip</code>.</li>
                            <li>Dalam skrip Python, impor pustaka Blynk. Inisialisasi pustaka dengan Auth Token yang Anda dapatkan. Buat perulangan yang membaca data sensor dan gunakan fungsi <code>blynk.virtual_write(pin_virtual, nilai_sensor)</code> untuk mengirim data ke Virtual Pin yang sesuai.</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>Widget (Gauge atau Labeled Value) di dasbor aplikasi Blynk pada perangkat seluler Anda menampilkan dan memperbarui nilai data sensor secara real-time sesuai dengan data yang dikirim oleh Raspberry Pi.</p>
                        <h5><i class="fa-solid fa-book"></i>ASET & REFERENSI</h5>
                        <div class="ref-links">
                            <ul>
                                <li><a href="https://blynk.io/" target="_blank" rel="noopener noreferrer"><i class="fa-solid fa-cloud"></i> Website Resmi Blynk</a></li>
                                <li><a href="https://docs.blynk.io/" target="_blank" rel="noopener noreferrer"><i class="fa-solid fa-book-open"></i> Dokumentasi Blynk</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Modul 14 -->
            <div class="module-card" data-module-id="14">
                <div class="module-header">
                    <div class="module-number">14</div><div class="module-icon"><i class="fa-solid fa-share-nodes"></i></div><div class="module-title">Arsitektur MQTT</div><div class="tag tag-menengah">Menengah</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                    <div class="module-body-content">
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Memahami arsitektur publish-subscribe dari protokol MQTT, sebuah standar industri untuk komunikasi IoT yang sangat ringan dan efisien, ideal untuk perangkat dengan sumber daya terbatas.</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI (Konseptual)</h5>
                        <ol>
                            <li>Identifikasi tiga komponen utama, analogikan dengan sistem pos: <strong>Publisher</strong> (pengirim surat/data), <strong>Subscriber</strong> (penerima surat/data), dan <strong>Broker</strong> (kantor pos).</li>
                            <li>Pahami konsep "Topic". Topic adalah string teks yang berfungsi sebagai alamat tujuan (misal, <code>rumah/kamar_tidur/suhu</code>). Ini bukan alamat fisik, melainkan sebuah kategori pesan.</li>
                            <li>Lacak alur pesan: Publisher tidak mengirim data langsung ke Subscriber. Publisher mengirim pesan ke sebuah Topic di Broker.</li>
                            <li>Broker kemudian meneruskan pesan tersebut ke semua Subscriber yang sebelumnya telah memberitahu Broker bahwa mereka tertarik pada Topic tersebut ("berlangganan").</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>Mampu menjelaskan peran setiap komponen (Publisher, Subscriber, Broker, Topic) dan alur data dalam skenario komunikasi MQTT. Memahami keuntungan arsitektur ini: Publisher dan Subscriber tidak perlu saling mengetahui keberadaan satu sama lain.</p>
                    </div>
                </div>
            </div>
            <!-- Modul 15 -->
            <div class="module-card" data-module-id="15">
                <div class="module-header">
                    <div class="module-number">15</div><div class="module-icon"><i class="fa-solid fa-server"></i></div><div class="module-title">Instalasi Broker MQTT Lokal</div><div class="tag tag-lanjutan">Lanjutan</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                    <div class="module-body-content">
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Menginstal dan menjalankan server perantara (broker) MQTT di Raspberry Pi itu sendiri. Ini menciptakan jaringan IoT lokal yang mandiri dan tidak memerlukan koneksi internet untuk beroperasi.</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI</h5>
                        <ol>
                            <li>Instal broker Mosquitto, salah satu broker MQTT paling populer, beserta klien baris perintahnya: <code>sudo apt install mosquitto mosquitto-clients</code>.</li>
                            <li>Verifikasi bahwa broker berjalan secara otomatis sebagai layanan sistem dengan <code>sudo systemctl status mosquitto</code>.</li>
                            <li>Buka dua jendela terminal secara bersamaan untuk simulasi.</li>
                            <li>Di terminal pertama, bertindak sebagai Subscriber: <code>mosquitto_sub -t "test/topic"</code>. Terminal ini sekarang akan mendengarkan pesan apa pun di topik "test/topic".</li>
                            <li>Di terminal kedua, bertindak sebagai Publisher: <code>mosquitto_pub -t "test/topic" -m "Halo Dunia"</code>. Perintah ini mengirimkan pesan "Halo Dunia" ke topik "test/topic".</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>Teks "Halo Dunia" yang dikirim dari terminal kedua langsung muncul di terminal pertama, menandakan broker berhasil menerima pesan dari publisher dan meneruskannya ke subscriber.</p>
                        <h5><i class="fa-solid fa-book"></i>ASET & REFERENSI</h5>
                        <div class="ref-links">
                            <ul>
                                <li><a href="https://mosquitto.org/" target="_blank" rel="noopener noreferrer"><i class="fa-solid fa-book-open"></i> Dokumentasi Mosquitto</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Modul 16 -->
            <div class="module-card" data-module-id="16">
                <div class="module-header">
                    <div class="module-number">16</div><div class="module-icon"><i class="fa-solid fa-arrow-right-arrow-left"></i></div><div class="module-title">Klien MQTT dengan Python</div><div class="tag tag-lanjutan">Lanjutan</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                    <div class="module-body-content">
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Mengintegrasikan fungsionalitas MQTT ke dalam skrip Python, memungkinkan program untuk mengirim (publish) dan menerima (subscribe) data secara terprogram, bukan hanya melalui baris perintah.</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI</h5>
                        <ol>
                            <li>Instal pustaka Paho-MQTT untuk Python: <code>pip install paho-mqtt</code>.</li>
                            <li>Buat skrip <strong>publisher.py</strong>: Impor pustaka, buat objek klien, hubungkan ke alamat broker (<code>localhost</code> atau IP broker), lalu gunakan metode <code>client.publish()</code> di dalam sebuah perulangan untuk mengirim data sensor.</li>
                            <li>Buat skrip <strong>subscriber.py</strong> yang terpisah: Impor pustaka, buat objek klien, dan definisikan fungsi callback (misal, <code>on_message</code>). Fungsi ini akan dieksekusi secara otomatis setiap kali pesan baru tiba di topik yang dilanggan.</li>
                            <li>Di skrip subscriber, hubungkan ke broker, berlangganan ke topik yang relevan dengan <code>client.subscribe()</code>, dan jalankan <code>client.loop_forever()</code> untuk memulai proses mendengarkan pesan tanpa henti.</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>Data yang dikirim oleh skrip <code>publisher.py</code> (misal, nilai sensor atau angka acak) muncul di konsol dari skrip <code>subscriber.py</code> yang sedang berjalan secara real-time.</p>
                        <h5><i class="fa-solid fa-book"></i>ASET & REFERENSI</h5>
                        <div class="ref-links">
                            <ul>
                                <li><a href="https://pypi.org/project/paho-mqtt/" target="_blank" rel="noopener noreferrer"><i class="fa-solid fa-book-open"></i> Dokumentasi Paho-MQTT</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Modul 17 -->
            <div class="module-card" data-module-id="17">
                <div class="module-header">
                    <div class="module-number">17</div><div class="module-icon"><i class="fa-solid fa-database"></i></div><div class="module-title">Instalasi Database Server</div><div class="tag tag-lanjutan">Lanjutan</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                    <div class="module-body-content">
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Menginstal dan mengamankan server database relasional (MariaDB, sebuah cabang dari MySQL) untuk penyimpanan data sensor secara persisten dan terstruktur.</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI</h5>
                        <ol>
                            <li>Instal paket server MariaDB: <code>sudo apt install mariadb-server</code>.</li>
                            <li>Jalankan skrip keamanan pasca-instalasi: <code>sudo mysql_secure_installation</code>. Ikuti petunjuk di layar untuk mengatur kata sandi <code>root</code>, menghapus pengguna anonim, dan menonaktifkan login <code>root</code> jarak jauh. Ini adalah langkah keamanan yang sangat penting.</li>
                            <li>Masuk ke antarmuka baris perintah database: <code>sudo mysql -u root -p</code>.</li>
                            <li>Gunakan perintah SQL <code>CREATE DATABASE nama_database;</code> untuk membuat database baru.</li>
                            <li>Gunakan <code>USE nama_database;</code> untuk memilihnya, lalu <code>CREATE TABLE nama_tabel (...)</code> untuk mendefinisikan struktur kolom yang akan menyimpan data sensor (misal, kolom untuk id, timestamp, dan nilai suhu).</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>Berhasil login ke server database menggunakan kredensial yang baru dibuat. Perintah <code>SHOW TABLES;</code> di dalam database yang benar akan menampilkan tabel yang baru saja Anda buat dengan struktur kolom yang benar.</p>
                        <h5><i class="fa-solid fa-book"></i>ASET & REFERENSI</h5>
                        <div class="ref-links">
                            <ul>
                                <li><a href="https://mariadb.com/kb/en/documentation/" target="_blank" rel="noopener noreferrer"><i class="fa-solid fa-book-open"></i> Dokumentasi MariaDB</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Modul 18 -->
            <div class="module-card" data-module-id="18">
                <div class="module-header">
                    <div class="module-number">18</div><div class="module-icon"><i class="fa-solid fa-plug-circle-check"></i></div><div class="module-title">Integrasi Python & Database</div><div class="tag tag-lanjutan">Lanjutan</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                    <div class="module-body-content">
                        <h5><i class="fa-solid fa-satellite-dish"></i>PRASYARAT</h5>
                        <p>Modul 16 (Klien MQTT) dan 17 (Instalasi Database) harus diselesaikan.</p>
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Menyimpan data sensor yang diterima oleh skrip Python (misalnya dari MQTT) secara permanen ke dalam tabel di database MariaDB.</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI</h5>
                        <ol>
                            <li>Instal konektor Python untuk MySQL/MariaDB: <code>pip install mysql-connector-python</code>. Pustaka ini berfungsi sebagai "penerjemah" antara bahasa Python dan bahasa SQL database.</li>
                            <li>Dalam skrip Python Anda (misalnya, skrip subscriber MQTT), impor pustaka konektor.</li>
                            <li>Buat koneksi ke database, dengan menyediakan parameter seperti host (<code>localhost</code>), user, password, dan nama database.</li>
                            <li>Buat objek "kursor" dari koneksi tersebut. Kursor adalah objek yang Anda gunakan untuk mengeksekusi perintah SQL.</li>
                            <li>Setiap kali data sensor baru diterima (misal, di dalam fungsi <code>on_message</code> MQTT), buat string perintah SQL <code>INSERT INTO nama_tabel (...) VALUES (...)</code> yang menyertakan data tersebut.</li>
                            <li>Gunakan <code>cursor.execute()</code> untuk menjalankan perintah SQL, lalu panggil <code>connection.commit()</code> untuk menyimpan perubahan secara permanen ke database.</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>Setelah skrip berjalan untuk beberapa saat, jalankan kueri <code>SELECT * FROM nama_tabel;</code> di klien <code>mysql</code>. Tabel akan berisi baris-baris data sensor yang dikirim oleh skrip Python, lengkap dengan timestamp.</p>
                    </div>
                </div>
            </div>
            <!-- Modul 19 -->
            <div class="module-card" data-module-id="19">
                <div class="module-header">
                    <div class="module-number">19</div><div class="module-icon"><i class="fa-solid fa-network-wired"></i></div><div class="module-title">Topologi Jaringan IoT</div><div class="tag tag-lanjutan">Lanjutan</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                    <div class="module-body-content">
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Merancang dan mengimplementasikan jaringan multi-perangkat yang lebih kompleks, seperti topologi bintang, di mana beberapa perangkat sensor ("Node") melaporkan data ke satu perangkat pusat ("Gateway").</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI</h5>
                        <ol>
                            <li>Tentukan satu Raspberry Pi sebagai "Gateway". Perangkat ini akan menjalankan broker MQTT (Mosquitto) dan mungkin juga database. Pastikan Gateway memiliki alamat IP statis.</li>
                            <li>Siapkan satu atau lebih perangkat lain (bisa Raspberry Pi, ESP32, dll.) sebagai "Node Sensor".</li>
                            <li>Pastikan semua perangkat (Gateway dan Node) terhubung ke jaringan WiFi yang sama.</li>
                            <li>Pada setiap Node, jalankan skrip publisher MQTT. Namun, kali ini, alamat broker yang dituju bukan lagi <code>localhost</code>, melainkan alamat IP statis dari Gateway.</li>
                            <li>Di Gateway, Anda dapat menjalankan skrip subscriber yang berlangganan ke topik dari semua node (misalnya menggunakan wildcard seperti <code>sensor/#</code>) untuk memantau atau menyimpan semua data yang masuk.</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>Log di broker Gateway atau output dari skrip subscriber di Gateway menunjukkan pesan masuk dari beberapa alamat IP Node yang berbeda, membuktikan komunikasi multi-perangkat berhasil.</p>
                    </div>
                </div>
            </div>
            <!-- Modul 20 -->
            <div class="module-card" data-module-id="20">
                <div class="module-header">
                    <div class="module-number">20</div><div class="module-icon"><i class="fa-solid fa-lock"></i></div><div class="module-title">Dasar Keamanan IoT</div><div class="tag tag-lanjutan">Lanjutan</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                    <div class="module-body-content">
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Menerapkan praktik keamanan dasar untuk melindungi perangkat IoT dari akses tidak sah dan ancaman umum, memperkuat pertahanan sistem.</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI</h5>
                        <ol>
                            <li><b>Ubah Kata Sandi Default:</b> Gunakan perintah <code>passwd</code> di terminal untuk mengubah kata sandi pengguna Anda menjadi sesuatu yang kuat dan unik.</li>
                            <li><b>Aktifkan Firewall:</b> Instal <code>ufw</code> (Uncomplicated Firewall). Gunakan <code>sudo ufw allow</code> hanya untuk port yang benar-benar Anda butuhkan (misal, 22 untuk SSH, 1883 untuk MQTT). Kemudian aktifkan dengan <code>sudo ufw enable</code>. Ini seperti menutup semua pintu dan hanya membuka beberapa yang diperlukan.</li>
                            <li><b>Amankan SSH:</b> Edit file <code>/etc/ssh/sshd_config</code>. Ubah baris <code>PermitRootLogin</code> menjadi <code>no</code> untuk mencegah login jarak jauh menggunakan akun paling kuat.</li>
                            <li><b>Amankan MQTT:</b> Konfigurasikan broker Mosquitto untuk memerlukan username dan password. Ini mencegah klien yang tidak dikenal terhubung, mempublikasikan data palsu, atau menguping data Anda.</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>Upaya login sebagai <code>root</code> melalui SSH ditolak. Upaya koneksi ke port yang tidak diizinkan oleh firewall gagal. Klien MQTT tidak dapat terhubung ke broker tanpa memberikan username dan password yang valid.</p>
                    </div>
                </div>
            </div>
            <!-- Modul 21 -->
            <div class="module-card" data-module-id="21">
                <div class="module-header">
                    <div class="module-number">21</div><div class="module-icon"><i class="fa-solid fa-window-maximize"></i></div><div class="module-title">Integrasi Web Framework Flask</div><div class="tag tag-lanjutan">Lanjutan</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                    <div class="module-body-content">
                        <h5><i class="fa-solid fa-satellite-dish"></i>PRASYARAT</h5>
                        <p>Pemahaman dasar Python (Modul 07) dan arsitektur MQTT (Modul 14 & 16) diperlukan.</p>
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Membangun sebuah backend aplikasi web minimalis menggunakan framework Python Flask, yang berfungsi sebagai jembatan antara data IoT real-time dari MQTT dan antarmuka pengguna berbasis web.</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI</h5>
                        <ol>
                            <li>Instalasi Flask. Gunakan manajer paket Python, <code>pip</code>, untuk menginstal framework: <code>pip install Flask</code>.</li>
                            <li>Rancang arsitektur skrip. Dalam satu file Python, impor pustaka yang diperlukan: <code>Flask</code> (untuk server web), <code>paho-mqtt</code> (untuk klien MQTT), dan <code>threading</code> (untuk menjalankan proses secara paralel).</li>
                            <li>Definisikan sebuah variabel global. Variabel ini akan bertindak sebagai 'papan tulis' sementara untuk menyimpan nilai sensor terakhir yang diterima dari MQTT.</li>
                            <li>Buat fungsi klien MQTT. Fungsi ini akan berisi logika untuk terhubung ke broker, berlangganan topik, dan dalam callback <code>on_message</code>, memperbarui nilai pada variabel global tadi. Fungsi ini harus berjalan dalam loop tak terbatas.</li>
                            <li>Jalankan MQTT di latar belakang. Gunakan pustaka <code>threading</code> untuk menjalankan fungsi klien MQTT dalam sebuah "thread" terpisah. Ini krusial agar klien MQTT tidak memblokir dan menghentikan server web.</li>
                            <li>Buat sebuah 'route' Flask. Route adalah alamat URL yang akan direspons oleh server. Gunakan dekorator <code>@app.route('/')</code> untuk mendefinisikan apa yang terjadi ketika seseorang mengakses alamat utama server. Fungsi di bawahnya harus membaca nilai dari variabel global dan mengembalikannya, misalnya sebagai teks atau format JSON.</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>Setelah skrip Flask dieksekusi dan data baru dipublikasikan ke topik MQTT yang relevan, mengakses alamat <code>http://localhost:5000</code> di browser Raspberry Pi akan menampilkan nilai data sensor terbaru. Halaman akan diperbarui dengan data baru setiap kali di-refresh.</p>
                        <h5><i class="fa-solid fa-book"></i>ASET & REFERENSI</h5>
                        <div class="ref-links">
                            <ul>
                                <li><a href="https://flask.palletsprojects.com/" target="_blank" rel="noopener noreferrer"><i class="fa-solid fa-book-open"></i> Dokumentasi Resmi Flask</a></li>
                                <li><a href="https://pypi.org/project/paho-mqtt/" target="_blank" rel="noopener noreferrer"><i class="fa-solid fa-book-open"></i> Dokumentasi Paho-MQTT</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
             <!-- Modul 22 -->
            <div class="module-card" data-module-id="22">
                <div class="module-header">
                    <div class="module-number">22</div><div class="module-icon"><i class="fa-solid fa-globe"></i></div><div class="module-title">Deployment Dasbor Web Lokal</div><div class="tag tag-lanjutan">Lanjutan</div><button class="complete-btn"><i class="fa-solid fa-check"></i></button>
                </div>
                <div class="module-body">
                    <div class="module-body-content">
                        <h5><i class="fa-solid fa-satellite-dish"></i>PRASYARAT</h5>
                        <p>Modul 21 (Integrasi Flask) harus telah diselesaikan. Raspberry Pi harus memiliki alamat IP statis yang diketahui (Modul 04).</p>
                        <h5><i class="fa-solid fa-bullseye"></i>OBJEKTIF SISTEM</h5>
                        <p>Men-deploy sebuah dasbor web dinamis yang fungsional di Raspberry Pi, membuatnya dapat diakses dari perangkat apa pun (laptop, ponsel) yang terhubung ke jaringan lokal yang sama.</p>
                        <h5><i class="fa-solid fa-list-check"></i>PROTOKOL EKSEKUSI</h5>
                        <ol>
                            <li>Strukturasi proyek. Buat sebuah direktori utama, dan di dalamnya, buat subdirektori bernama <code>templates</code>. Flask secara otomatis mencari file HTML di dalam folder ini.</li>
                            <li>Buat file HTML. Di dalam folder <code>templates</code>, buat file <code>index.html</code>. File ini adalah cetak biru visual dasbor Anda. Gunakan sintaks Jinja2 (misal, <code><h1>Suhu: {{ data_suhu }} &deg;C</h1></code>) sebagai placeholder di mana data dinamis akan disisipkan.</li>
                            <li>Modifikasi skrip Flask. Impor fungsi <code>render_template</code> dari Flask. Pada fungsi route utama, ubah pernyataan <code>return</code> menjadi <code>return render_template('index.html', data_suhu=variabel_global_suhu)</code>. Ini memerintahkan Flask untuk mengambil file HTML, mengganti placeholder dengan nilai variabel saat ini, dan mengirimkan hasilnya ke browser.</li>
                            <li>Konfigurasi akses jaringan. Pada baris terakhir skrip saat memanggil <code>app.run()</code>, tambahkan argumen <code>host='0.0.0.0'</code>. Pengaturan ini memberitahu server untuk 'mendengarkan' koneksi dari semua alamat IP di jaringan, bukan hanya dari <code>localhost</code> (dirinya sendiri).</li>
                            <li>Akses dari perangkat lain. Jalankan skrip Flask. Di laptop atau ponsel yang terhubung ke jaringan WiFi yang sama, buka browser dan navigasi ke <code>http://<ALAMAT_IP_RASPBERRY_PI>:5000</code>.</li>
                        </ol>
                        <h5><i class="fa-solid fa-flag-checkered"></i>VERIFIKASI STATUS OPERASIONAL</h5>
                        <p>Halaman dasbor berhasil dimuat di browser perangkat eksternal. Halaman tersebut menampilkan data sensor yang paling mutakhir sesuai dengan format yang didefinisikan dalam file <code>index.html</code>. Data yang ditampilkan berubah jika halaman di-refresh setelah sensor mengirim pembaruan.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="closing-statement">
            <h3>Sistem Operasional Lengkap</h3>
            <p>Anda telah menyelesaikan semua 22 modul. Sistem pengetahuan dasar dan lanjutan untuk operasi Raspberry Pi dan IoT telah terbentuk. Lanjutkan eksplorasi mandiri.</p>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const moduleCards = document.querySelectorAll('.module-card');
            const progressBar = document.getElementById('progressBar');
            const totalModules = moduleCards.length;
            let completedModules = new Set(JSON.parse(localStorage.getItem('completedModules')) || []);

            function updateProgress() {
                const progressPercentage = (completedModules.size / totalModules) * 100;
                progressBar.style.width = progressPercentage + '%';
                progressBar.textContent = `${Math.round(progressPercentage)}% Selesai`;
            }

            function saveProgress() {
                localStorage.setItem('completedModules', JSON.stringify(Array.from(completedModules)));
            }

            moduleCards.forEach(card => {
                const moduleId = card.dataset.moduleId;
                const header = card.querySelector('.module-header');
                const completeBtn = card.querySelector('.complete-btn');

                if (completedModules.has(moduleId)) {
                    card.classList.add('completed');
                }

                header.addEventListener('click', (e) => {
                    if (e.target.closest('.complete-btn')) {
                        return;
                    }
                    // Close other active cards for a cleaner accordion experience
                    if (!card.classList.contains('active')) {
                        moduleCards.forEach(otherCard => {
                            if (otherCard.classList.contains('active')) {
                                otherCard.classList.remove('active');
                            }
                        });
                    }
                    card.classList.toggle('active');
                });

                completeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    card.classList.toggle('completed');
                    if (card.classList.contains('completed')) {
                        completedModules.add(moduleId);
                    } else {
                        completedModules.delete(moduleId);
                    }
                    saveProgress();
                    updateProgress();
                });
            });

            updateProgress();
        });
    </script>
</body>
</html>
